# Redis Cluster Configuration for Distributed Rate Limiting

## This file provides Redis configuration for the distributed rate limiter
## Supporting both standalone Redis and Redis Cluster setups

# Redis Cluster Configuration (docker-compose.yml)
services:
  redis-cluster:
    image: redis:7-alpine
    ports:
      - "7000-7005:7000-7005"
    volumes:
      - redis-cluster-data:/data
    command: |
      sh -c '
        mkdir -p /usr/local/etc/redis &&
        for port in 7000 7001 7002 7003 7004 7005; do
          mkdir -p /usr/local/etc/redis/$$port
          cat > /usr/local/etc/redis/$$port/redis.conf <<EOF
        port $$port
        cluster-enabled yes
        cluster-config-file nodes-$$port.conf
        cluster-node-timeout 5000
        appendonly yes
        appendfilename "appendonly-$$port.aof"
        dir /usr/local/etc/redis/$$port
        save 900 1
        save 300 10
        save 60 10000
        maxmemory 256mb
        maxmemory-policy allkeys-lru
        EOF
          redis-server /usr/local/etc/redis/$$port/redis.conf --daemonize yes
        done &&
        sleep 5 &&
        echo "yes" | redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1 &&
        wait
      '
    networks:
      - api-network

  # Individual Redis nodes for cluster (alternative approach)
  redis-node-1:
    image: redis:7-alpine
    command: redis-server --port 7000 --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly yes
    ports:
      - "7000:7000"
    volumes:
      - redis-node-1:/data
    networks:
      - api-network

  redis-node-2:
    image: redis:7-alpine
    command: redis-server --port 7001 --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly yes
    ports:
      - "7001:7001"
    volumes:
      - redis-node-2:/data
    networks:
      - api-network

  redis-node-3:
    image: redis:7-alpine
    command: redis-server --port 7002 --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly yes
    ports:
      - "7002:7002"
    volumes:
      - redis-node-3:/data
    networks:
      - api-network

  redis-node-4:
    image: redis:7-alpine
    command: redis-server --port 7003 --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly yes
    ports:
      - "7003:7003"
    volumes:
      - redis-node-4:/data
    networks:
      - api-network

  redis-node-5:
    image: redis:7-alpine
    command: redis-server --port 7004 --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly yes
    ports:
      - "7004:7004"
    volumes:
      - redis-node-5:/data
    networks:
      - api-network

  redis-node-6:
    image: redis:7-alpine
    command: redis-server --port 7005 --cluster-enabled yes --cluster-config-file nodes.conf --cluster-node-timeout 5000 --appendonly yes
    ports:
      - "7005:7005"
    volumes:
      - redis-node-6:/data
    networks:
      - api-network

  # Cluster initialization service
  redis-cluster-init:
    image: redis:7-alpine
    depends_on:
      - redis-node-1
      - redis-node-2
      - redis-node-3
      - redis-node-4
      - redis-node-5
      - redis-node-6
    command: |
      sh -c '
        sleep 10 &&
        echo "yes" | redis-cli --cluster create \
          redis-node-1:7000 \
          redis-node-2:7001 \
          redis-node-3:7002 \
          redis-node-4:7003 \
          redis-node-5:7004 \
          redis-node-6:7005 \
          --cluster-replicas 1
      '
    networks:
      - api-network

volumes:
  redis-cluster-data:
  redis-node-1:
  redis-node-2:
  redis-node-3:
  redis-node-4:
  redis-node-5:
  redis-node-6:

networks:
  api-network:
    driver: bridge

---

# Environment Variables for Distributed Configuration

# Distributed Redis Configuration
DISTRIBUTED_REDIS_MODE=cluster  # cluster | single
REDIS_CLUSTER_NODES=redis-node-1:7000,redis-node-2:7001,redis-node-3:7002,redis-node-4:7003,redis-node-5:7004,redis-node-6:7005

# Single Redis fallback
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0

# Instance coordination
INSTANCE_ID=api-rate-limiter-${HOSTNAME:-unknown}-${PORT:-3000}
COORDINATION_PREFIX=rate_limiter:distributed
COORDINATION_STRATEGY=consistent-hashing  # consistent-hashing | broadcast | leader-follower

# Circuit breaker configuration
CIRCUIT_BREAKER_ENABLED=true
CIRCUIT_BREAKER_FAILURE_THRESHOLD=5
CIRCUIT_BREAKER_SUCCESS_THRESHOLD=3
CIRCUIT_BREAKER_TIMEOUT=60000
CIRCUIT_BREAKER_DEGRADED_LIMIT=100

# Performance monitoring
MONITORING_ENABLED=true
MONITORING_ERROR_RATE_THRESHOLD=0.05  # 5%
MONITORING_LATENCY_THRESHOLD=1000     # 1 second
MONITORING_MEMORY_THRESHOLD=0.8       # 80%

# Rate limiting defaults
DEFAULT_RATE_LIMIT_ALGORITHM=sliding-window
DEFAULT_RATE_LIMIT_LIMIT=1000
DEFAULT_RATE_LIMIT_WINDOW_MS=3600000  # 1 hour

---

# Kubernetes Configuration for Redis Cluster

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: redis-cluster
  namespace: api-rate-limiter
spec:
  serviceName: redis-cluster
  replicas: 6
  selector:
    matchLabels:
      app: redis-cluster
  template:
    metadata:
      labels:
        app: redis-cluster
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
          name: client
        - containerPort: 16379
          name: gossip
        command:
        - redis-server
        args:
        - /etc/redis/redis.conf
        - --cluster-enabled
        - yes
        - --cluster-config-file
        - /data/nodes.conf
        - --cluster-node-timeout
        - "5000"
        - --appendonly
        - yes
        - --protected-mode
        - no
        volumeMounts:
        - name: data
          mountPath: /data
        - name: config
          mountPath: /etc/redis
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: config
        configMap:
          name: redis-cluster-config
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi

---

apiVersion: v1
kind: Service
metadata:
  name: redis-cluster
  namespace: api-rate-limiter
spec:
  type: ClusterIP
  clusterIP: None
  ports:
  - port: 6379
    targetPort: 6379
    name: client
  - port: 16379
    targetPort: 16379
    name: gossip
  selector:
    app: redis-cluster

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-cluster-config
  namespace: api-rate-limiter
data:
  redis.conf: |
    port 6379
    cluster-enabled yes
    cluster-require-full-coverage no
    cluster-node-timeout 15000
    cluster-config-file /data/nodes.conf
    cluster-migration-barrier 1
    appendonly yes
    appendfilename "appendonly.aof"
    save 900 1
    save 300 10
    save 60 10000
    maxmemory 256mb
    maxmemory-policy allkeys-lru
    tcp-keepalive 60
    tcp-backlog 511
    timeout 0
    databases 1

---

# Load Balancer Configuration for Distributed API Instances

upstream api_backend {
    least_conn;
    server api-instance-1:3000 max_fails=3 fail_timeout=30s;
    server api-instance-2:3000 max_fails=3 fail_timeout=30s;
    server api-instance-3:3000 max_fails=3 fail_timeout=30s;
    
    # Health check configuration
    check interval=3000 rise=2 fall=3 timeout=1000;
}

server {
    listen 80;
    server_name api-rate-limiter.local;
    
    # Rate limiting at load balancer level
    limit_req_zone $binary_remote_addr zone=global:10m rate=100r/s;
    limit_req zone=global burst=200 nodelay;
    
    # Connection limiting
    limit_conn_zone $binary_remote_addr zone=addr:10m;
    limit_conn addr 50;
    
    location / {
        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Circuit breaker configuration
        proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 30s;
        
        # Timeout configuration
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 30s;
        
        # Health check header
        proxy_set_header X-Load-Balancer-Instance nginx;
    }
    
    # Health check endpoint
    location /health/load-balancer {
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }
    
    # Distributed rate limiter stats endpoint
    location /stats/distributed {
        proxy_pass http://api_backend/stats/distributed;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        
        # Restrict access to monitoring systems
        allow 10.0.0.0/8;
        allow 172.16.0.0/12;
        allow 192.168.0.0/16;
        deny all;
    }
}

---

# Monitoring and Alerting Configuration

# Prometheus monitoring for distributed rate limiter
- job_name: 'api-rate-limiter-distributed'
  static_configs:
    - targets: 
      - 'api-instance-1:3000'
      - 'api-instance-2:3000' 
      - 'api-instance-3:3000'
  metrics_path: '/metrics'
  scrape_interval: 15s
  scrape_timeout: 10s

# Redis cluster monitoring  
- job_name: 'redis-cluster'
  static_configs:
    - targets:
      - 'redis-node-1:6379'
      - 'redis-node-2:6379'
      - 'redis-node-3:6379'
      - 'redis-node-4:6379'
      - 'redis-node-5:6379'
      - 'redis-node-6:6379'
  metrics_path: '/metrics'
  scrape_interval: 30s

# Alerting rules for distributed rate limiter
groups:
- name: distributed-rate-limiter
  rules:
  - alert: HighErrorRate
    expr: rate(api_rate_limiter_errors_total[5m]) > 0.05
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "High error rate in distributed rate limiter"
      description: "Error rate is {{ $value }} errors per second"

  - alert: RedisClusterDown
    expr: redis_up == 0
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "Redis cluster node is down"
      description: "Redis node {{ $labels.instance }} is not responding"

  - alert: CircuitBreakerOpen
    expr: api_rate_limiter_circuit_breaker_state == 1
    for: 1m
    labels:
      severity: warning
    annotations:
      summary: "Circuit breaker is open"
      description: "Circuit breaker for {{ $labels.instance }} is open, using fallback"

  - alert: HighMemoryUsage
    expr: process_resident_memory_bytes / (1024*1024*1024) > 1
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High memory usage"
      description: "Memory usage is {{ $value }}GB on {{ $labels.instance }}"
